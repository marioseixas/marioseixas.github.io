---
categories:
  - Code
tags:
  - linux
  - scripts
comment: 
info: fechado.
date: '2024-02-22'
type: post
layout: post
published: true
slug: cat-files
title: 'cat files contents [script]'

---

```
#!/bin/bash

# Define directories and files
SEARCH_DIR="${1:-$HOME/Documents}"
DEST_DIR="${2:-$HOME/Downloads}"
FINAL_FILE="${DEST_DIR}/final_concatenated_file.txt"
UNSUPPORTED_FILE="${DEST_DIR}/concatenated_contents_unsupported.txt"
TEMP_FILE="${DEST_DIR}/temp_file_list.txt"

# Check if output is textual
is_output_textual() {
    local file="$1"
    local is_text=0

    # Check if the file contains null bytes
    if grep -q $'\0' "$file"; then
        is_text=0
    else
        # Extract printable strings from the file
        local strings_output=$(strings "$file")
        local strings_length=${#strings_output}
        local file_size=$(stat -c%s "$file")

        # Check if the length of extracted strings is significant
        if [ $strings_length -ge $((file_size / 2)) ]; then
            is_text=1
        else
            is_text=0
        fi
    fi

    if [[ $is_text -eq 0 ]]; then
        # Define the list of supported file MIME types
        supported_types=(
            "text/plain"
            "text/markdown"
            "text/x-log"
            "text/x-srt"
            "text/x-microdvd"
            "text/csv"
            "text/xml"
            "application/json"
            "application/mbox"
            "application/vnd.ms-word"
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            "application/vnd.oasis.opendocument.text"
            "application/vnd.oasis.opendocument.spreadsheet"
            "application/vnd.oasis.opendocument.presentation"
            "application/pdf"
            "application/rtf"
            "text/html"
            "application/x-python"
            "application/java-archive"
            "text/javascript"
            "text/x-c++src"
            "text/x-chdr"
            "application/x-zip-compressed"
            "application/x-rar-compressed"
            "application/x-tar"
            "application/gzip"
            "application/vnd.ms-powerpoint"
            "application/vnd.openxmlformats-officedocument.presentationml.presentation"
            "text/x-tex"
        )

        # Check if the file MIME type is in the supported types list
        local mime_type=$(file -b --mime-type "$file")
        for supported_type in "${supported_types[@]}"; do
            if [[ "${mime_type}" == "${supported_type}" ]]; then
                is_text=1
                break
            fi
        done
    fi

    if [[ $is_text -eq 0 ]]; then
        return 1
    else
        return 0
    fi
}

# Process individual file
process_file() {
    local file="$1"
    local text_file_path="$2"
    if [[ -f "$file" ]]; then
        case "${file##*.}" in
            pdf|docx|html|htm|srt|sub|log|tex|latex|doc|ppt|pptx|zip|rar|tar|gz|odt|ods|odp|rtf|csv|xml|json|py|java|js|cpp|h|md|markdown|txt|eml|mbox)
                echo "Processing file: $file"
                # Convert file to text and check if conversion is successful
                convert_to_text "$file" "$text_file_path"
                if [[ $? -ne 0 ]]; then
                    echo "Error: Failed to convert $file" >&2
                    return 1
                fi
                ;;
            *)
                # Unsupported file types are processed using 'cat' command
                echo "Warning: Unsupported file type '${file##*.}'. Processing using 'cat' command." >&2
                cat "$file" > "$text_file_path" 2>/dev/null
                
                # Initialize a counter for failed checks
                failed_checks=0
                
                # Check for null bytes
                if grep -q $'\0' "$text_file_path"; then
                    failed_checks=$((failed_checks + 1))
                fi
                
                # Check the significance of extracted printable strings
                strings_output=$(strings "$text_file_path")
                strings_length=${#strings_output}
                file_size=$(stat -c%s "$text_file_path")
                if [ $strings_length -lt $((file_size / 2)) ]; then
                    failed_checks=$((failed_checks + 1))
                fi
                
                # Check the file's MIME type
                mime_type=$(file -b --mime-type "$text_file_path")
                supported_type=0
                for type in "${supported_types[@]}"; do
                    if [[ "${mime_type}" == "${type}" ]]; then
                        supported_type=1
                        break
                    fi
                done
                if [[ $supported_type -eq 0 ]]; then
                    failed_checks=$((failed_checks + 1))
                fi
                
                # Determine the output file based on the number of failed checks
                if [[ $failed_checks -gt 2 ]]; then
                    echo "Warning: Output of $file failed more than two checks. Appending to unsupported file." >&2
                    cat "$text_file_path" >> "$UNSUPPORTED_FILE"
                    rm -f "$text_file_path"
                else
                    echo "Output of $file passed the checks. Appending to final file."
                    cat "$text_file_path" >> "$FINAL_FILE"
                    rm -f "$text_file_path"
                fi
                return 1
                ;;
        esac
        if ! is_output_textual "$text_file_path"; then
            echo "Warning: Output of $file is not textual. Skipping." >&2
            rm -f "$text_file_path"
            return 1
        fi
    else
        echo "Warning: '$file' is not a regular file. Skipping." >&2
        return 1
    fi
    echo "File $file processed successfully"
    return 0
}

# Convert file to text based on its type
convert_to_text() {
    local file="$1"
    local text_file_path="$2"
    case "${file##*.}" in
        pdf)
            echo "Converting $file using pdftotext..."
            pdftotext "$file" "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to convert $file using pdftotext" >&2
                return 1
            fi
            echo "Conversion of $file completed successfully"
            ;;
        docx|odt|ods|odp)
            echo "Converting $file using pandoc..."
            pandoc "$file" -t plain -o "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to convert $file using pandoc" >&2
                return 1
            fi
            echo "Conversion of $file completed successfully"
            ;;
        html|htm)
            echo "Converting $file using lynx..."
            lynx -dump -nolist -assume_charset UTF-8 -display_charset UTF-8 "$file" > "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to convert $file using lynx" >&2
                return 1
            fi
            echo "Conversion of $file completed successfully"
            ;;
        srt|sub|log|tex|latex|py|java|js|cpp|h|md|markdown|txt|eml|mbox)
            echo "Copying $file..."
            cat "$file" > "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to copy $file" >&2
                return 1
            fi
            echo "Copying of $file completed successfully"
            ;;
        doc)
            echo "Converting $file using antiword..."
            antiword "$file" > "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to convert $file using antiword" >&2
                return 1
            fi
            echo "Conversion of $file completed successfully"
            ;;
        ppt|pptx)
            echo "Converting $file using catppt..."
            catppt "$file" > "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to convert $file using catppt" >&2
                return 1
            fi
            echo "Conversion of $file completed successfully"
            ;;
        zip|rar|tar|gz)
            echo "Extracting and processing $file..."
            extract_and_process_archive "$file" "$text_file_path"
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to extract and process $file" >&2
                return 1
            fi
            echo "Extraction and processing of $file completed successfully"
            ;;
        rtf)
            echo "Converting $file using unrtf..."
            unrtf --text "$file" > "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to convert $file using unrtf" >&2
                return 1
            fi
            echo "Conversion of $file completed successfully"
            ;;
        csv)
            echo "Processing $file using awk..."
            awk -F, '{print}' "$file" > "$text_file_path"
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to process $file using awk" >&2
                return 1
            fi
            echo "Processing of $file completed successfully"
            ;;
        xml)
            echo "Processing $file using xmllint..."
            xmllint --xpath "//text()" "$file" > "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to process $file using xmllint" >&2
                return 1
            fi
            echo "Processing of $file completed successfully"
            ;;
        json)
            echo "Converting $file using jq..."
            jq -r '.' "$file" > "$text_file_path" 2>/dev/null
            if [[ $? -ne 0 ]]; then
                echo "Error: Failed to convert $file using jq" >&2
                return 1
            fi
            echo "Conversion of $file completed successfully"
            ;;
    esac
    return 0
}

# Extract and process archive files
extract_and_process_archive() {
    local file="$1"
    local text_file_path="$2"
    local temp_dir=$(mktemp -d)
    case "${file##*.}" in
        zip)
            echo "Extracting $file using unzip..."
            unzip -q "$file" -d "$temp_dir"
            ;;
        rar)
            echo "Extracting $file using unrar..."
            unrar x "$file" "$temp_dir"
            ;;
        tar)
            echo "Extracting $file using tar..."
            tar -xf "$file" -C "$temp_dir"
            ;;
        gz)
            echo "Extracting $file using gunzip..."
            gunzip -c "$file" > "$temp_dir/$(basename "$file" .gz)"
            ;;
    esac
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to extract archive '$file'" >&2
        rm -rf "$temp_dir"
        return 1
    fi
    echo "Extraction of $file completed successfully"
    while IFS= read -r -d '' nested_file; do
        echo "Processing nested file: $nested_file"
        process_file "$nested_file" "$text_file_path"
    done < <(find "$temp_dir" -type f -print0)
    rm -rf "$temp_dir"
    return 0
}

# Concatenate files
concatenate_files() {
    local text_file_path="$1"
    cat "$text_file_path" >> "$FINAL_FILE" 2>/dev/null
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to concatenate $text_file_path" >&2
        return 1
    fi
    echo "Concatenation of $text_file_path completed successfully"
    return 0
}

# Cleanup temporary files
cleanup_temp_files() {
    find "$DEST_DIR" -type f -name "*.txt" ! -name "$(basename "$FINAL_FILE")" ! -name "$(basename "$UNSUPPORTED_FILE")" -delete
    echo "Cleanup of temporary files completed successfully"
}

# Main script execution starts here
mkdir -p "$SEARCH_DIR" "$DEST_DIR"
> "$FINAL_FILE"
> "$UNSUPPORTED_FILE"
find "$SEARCH_DIR" -type f > "$TEMP_FILE"

while IFS= read -r file; do
    text_file_name=$(echo "$file" | sed 's/[^a-zA-Z0-9]/_/g')
    text_file_path="${DEST_DIR}/${text_file_name}.txt"
    if process_file "$file" "$text_file_path"; then
        concatenate_files "$text_file_path"
    fi
done < "$TEMP_FILE"

cleanup_temp_files
rm -f "$TEMP_FILE"

echo "Process completed. All files have been processed and concatenated into ${FINAL_FILE}."
echo "Unsupported file types have been processed using 'cat' command and concatenated into ${UNSUPPORTED_FILE}."
```
